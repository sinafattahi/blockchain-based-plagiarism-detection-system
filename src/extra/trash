// // ============================================
// // Main Process Article Function (IMPROVED)
// // ============================================
// async function processArticle(articleId, article, signer) {
//   console.log(`\n${"=".repeat(60)}`);
//   console.log(`Processing Article ${articleId}`);
//   console.log(`${"=".repeat(60)}`);

//   // Step 1: Document-level BERT check (optional but fast)
//   const docCheck = await checkDocumentSimilarity(articleId, article);
//   if (docCheck.isDuplicate) {
//     console.log(`⛔ Article ${articleId} is a document-level duplicate`);
//     console.log(`   Similar to: ${docCheck.similarArticleId}`);
//     console.log(`   Similarity: ${docCheck.similarity.toFixed(3)}`);
//     return false;
//   }

//   // Step 2: Sentence-level processing
//   const sentences = article.split("\n").filter((s) => s.trim().length > 0);
//   const sentenceHashes = sentences.map(computeHash);

//   const duplicateResults = [];
//   const uniqueHashes = [];
//   const uniqueSentences = [];

//   let lshDetections = 0;
//   let bertVerifications = 0;
//   let bertOverrides = 0;

//   for (let i = 0; i < sentences.length; i++) {
//     const sentence = sentences[i];
//     const sentenceHash = sentenceHashes[i];

//     console.log(`\n[${i + 1}/${sentences.length}] Processing sentence...`);

//     const shingles = createShingles(sentence);
//     const signature = generateSignature(shingles);

//     // Hybrid LSH + BERT detection
//     const result = await findSimilarSentencesHybrid(
//       sentence,
//       sentenceHash,
//       signature,
//       articleId
//     );
//     duplicateResults.push(result);

//     // Track detection methods
//     if (result.detectionMethod && result.detectionMethod.includes("LSH"))
//       lshDetections++;
//     if (result.detectionMethod && result.detectionMethod.includes("BERT"))
//       bertVerifications++;
//     if (result.detectionMethod === "BERT-Override") bertOverrides++;

//     if (result.isDuplicate) {
//       console.log(`   ✗ DUPLICATE FOUND`);
//       console.log(`     Method: ${result.detectionMethod}`);
//       console.log(`     Similarity: ${result.similarity.toFixed(3)}`);
//       if (result.lshSimilarity) {
//         console.log(`     LSH: ${result.lshSimilarity.toFixed(3)}`);
//       }
//       console.log(
//         `     Matched: "${(result.matchedSentence || "").substring(0, 60)}..."`
//       );
//     } else {
//       console.log(`   ✓ UNIQUE`);
//       if (!uniqueSentences.includes(sentence)) {
//         uniqueSentences.push(sentence);
//         uniqueHashes.push(sentenceHash);
//       }
//     }
//   }

//   // Step 3: Compute score and ratio
//   const score = computeScore(duplicateResults);
//   const ratio = sentences.length ? score / sentences.length : 0;

//   addRatioToStats(ratio);

//   console.log(`\n${"=".repeat(60)}`);
//   console.log(`Article ${articleId} Summary:`);
//   console.log(`  - Total sentences: ${sentences.length}`);
//   console.log(`  - Unique sentences: ${uniqueSentences.length}`);
//   console.log(`  - Duplicate score: ${score}`);
//   console.log(`  - Duplication ratio: ${ratio.toFixed(3)}`);
//   console.log(`  - LSH detections: ${lshDetections}`);
//   console.log(`  - BERT verifications: ${bertVerifications}`);
//   console.log(`  - BERT overrides: ${bertOverrides}`);
//   console.log(`${"=".repeat(60)}`);

//   if (ratio > 0.3) {
//     console.log(`⛔ Article ${articleId} REJECTED (ratio > 0.3)`);
//     return false;
//   }

//   // Step 4: Store unique sentences
//   for (let i = 0; i < uniqueSentences.length; i++) {
//     const sentence = uniqueSentences[i];
//     const sentenceHash = uniqueHashes[i];
//     const shingles = createShingles(sentence);
//     const signature = generateSignature(shingles);

//     storeSentenceInLSH(sentence, sentenceHash, signature);
//   }

//   // Step 5: Store on IPFS and Blockchain
//   try {
//     const hashesData = JSON.stringify(uniqueHashes);
//     const hashesBuffer = Buffer.from(hashesData);
//     const ipfsCid = await uploadToIPFS(hashesBuffer);
//     console.log(`✓ Stored on IPFS: ${ipfsCid}`);

//     const contract = new Contract(contractAddress, contractAbi, signer);
//     const tx = await contract.storeArticleCID(articleId, ipfsCid, {
//       gasLimit: 1_000_000,
//     });
//     await tx.wait();
//     console.log(`✓ Stored on blockchain: ${tx.hash}`);
//   } catch (error) {
//     console.error("✗ Storage error:", error);
//     return false;
//   }

//   await saveCache();
//   console.log(`✅ Article ${articleId} ACCEPTED\n`);
//   return true;
// }